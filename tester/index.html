<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><head>
<style>
  body {
    background-color: #000;
    color: #eee;
  }
  h2 {
    margin: 0;
    font-size: 1em;
  }
  #strip {
    position: absolute;
    top: 600px;
    left: 600px;
    width: 100px;
    height: 100px;
    border-top: 1px solid #000;
  }
  .led {
    width:6px;
    height:6px;
    border-radius:4px;
    position:absolute;
  }
  #controls {
    max-width: 30em;
    height: 90vh;
    overflow: auto;
    position: absolute;
    right: 5px;
    background-color: #ccc;
  }
  #controls > fieldset {
    display: flex;
    overflow: hidden;
    height: 1.5em;
    opacity: 0.6;
    color: #000;
  }
  #controls > fieldset.selected {
    overflow: visible;
    opacity: 1;
  }
  #controls > fieldset > * {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 0 0.5em;
  }
</style>
</head>
<body>

<section id="controls">
  <fieldset>
    <input name="animation" type="radio" selected value="allOff">
    <h2>allOff</h2>
  </fieldset>

  <fieldset>
    <input name="animation" type="radio" value="colorFade">
    <h2>colorFade</h2>
    <input type="color" name="color1">
    <input type="color" name="color2">
  </fieldset>

  <fieldset>
    <input name="animation" type="radio" value="colorFade">
    <h2>swipe</h2>
    <input type="color" name="color1">
  </fieldset>
  <button id="send">Enqueue</button>
</section>
<script>
  let theForm = {
    init() {
      this.radios = document.querySelectorAll("[name='animation']");
      let target = this.radios[0];
      for (input of this.radios) {
        input.addEventListener('click', this);
        if (input.checked) {
          target = input;
        }
      }
      this.handleSelection({ target });
      this.sendButton = document.querySelector("#send");
      this.sendButton.addEventListener("click", this);
    },
    handleEvent(evt) {
      switch (evt.type) {
        case 'click': {
          if (evt.target.type == "radio") {
            this.handleSelection(evt);
          }
          if (evt.target == this.sendButton) {
            this.sendForm();
          }
          break;
        }
      }
    },
    handleSelection(evt) {
      for(let input of this.radios) {
        input.parentElement.classList.toggle("selected", input == evt.target);
      }
    },
    sendForm() {
      let container = document.querySelector("fieldset.selected");
      let inputs = container.querySelectorAll("input");
      let data = {};
      for (let input of inputs) {
        data[input.name] = input.value;
      }
      console.log("data: ", data);
    }
  };
  document.addEventListener("DOMContentLoaded", () => { theForm.init() });
</script>
<!--
remote inputs:
accept name + params for animation
  fade, color1, color2, duration
  ripple, color1, duration
accept reset?
accept wifi credentials?
accept network conditions/errors

outputs:
remote: status response (200 ok etc. )

external parts:
UI for assembling json message and POSTing it to the server
MQTT broker?

input system
  knows how to get inputs from whatever and queue them up for action next time around the loop
  it manages an inputs buffer
updateAnimationState
  turns the inputs it finds into rgb values for this frame. It manages the animation tracks
  and could do tweening.
  it leaves messages or other output for the output system to do stuff with
  it manages an outputs buffer
  it manages a series of animation tracks

output system
  serial output?
  server response
  render to led strip: compose together the tracks to produce output for the LED strip
-->

<h1>Animation tester</h1>

<div id="strip"></div>
<script>
"use strict";

var stopNow;
const NUM_PIXELS = 60;

let gNowMs, gPreviousMs;
let stateTransitionTime = 0;
let animations = {};
let fxController;
let inputController;
let inputState = {};

const StateEnum = {
  start_state: 0,
  off_transition: 1,
  off_state: 2,
  connecting: 3,
  connected: 4,
};
let currentState;
let previousState;

// ================================
// Helpers, shims

function clamp(num, lbound, ubound) {
  if (num < lbound) {
    num = lbound;
  }
  if (num > ubound) {
    num = ubound;
  }
  return num;
}

function debugPrint(...args) {
  console.log(...args);
}

function millis() {
  return Date.now();
}
// ================================

function setup() {
  gNowMs = millis();
  gPreviousMs = gNowMs;

  currentState = StateEnum.start_state;

  fxController = new Fx_Controller(NUM_PIXELS);
  fxController.start();

  inputController = new Input_Controller(inputState); // TODO: make one
  inputController.start();
  display();
}

function processInput() {
  // say we got a remote command saying "gamestart"
  // turn that into something actionable in updateState
  if (currentState !== StateEnum.connected) {
    return;
  }
  switch (inputState.topic) {
    case "gamestart": {
      let params = new Fx_AnimationParams({r:0,g:0,b:0}, {r:0,g:155,b:255});
      let seq = new Fx_Controller_Clip(
        animations.colorBlink, // animation
        gNowMs,                // startTime
        2000,                  // duration
        0,                     // repeat
        params,
      );
      fxController.addClip(seq);
      break;
    }
    case "gameend": {
      let params = new Fx_AnimationParams({r:0,g:155,b:255}, {r:255,g:255,b:0});
      let seq = new Fx_Controller_Clip(
        animations.colorBlink, // animation
        gNowMs,                // startTime
        2000,                  // duration
        0,                     // repeat
        params,
      );
      fxController.addClip(seq);
      break;
    }
  }
  // clear state data once we've handled it
  delete inputState.topic;
  delete inputState.params;
}

function loop() {
  gNowMs = millis();
  // inputController.update();
  processInput();
  updateState();
  fxController.updateTimeline();
  display();
  if (!stopNow) {
    window.requestAnimationFrame(loop);
  }
}

function updateState() {

  // states are predefined macro-level states of being for the whole thing
  // like "starting", "connecting", "connected", "playing", "disconnected"
  // the may utilize the animation engine, or not
  // console.log("updateState, currentState: ", currentState);

  console.log("updateState, currentState: " + currentState);
  switch (currentState) {
    case StateEnum.start_state :
      // do something??
      stateTransitionTime = 0;
      previousState = currentState;
      currentState = StateEnum.connecting;
      console.log("updateState, switching to 'connected' state");
      break;
    case StateEnum.connecting :
      if (previousState !== currentState) {
        console.log("updateState, connecting state entry");
        // state entry, queue up an animation
        let params = new Fx_AnimationParams({r:0,g:155,b:255}, {r:255,g:255,b:0});
        let clip = new Fx_Controller_Clip(
          Fx_Animations.blueBlink, // animation
          gNowMs,                  // startTime
          2000,                    // duration
          Infinity,                // repeat
          params,
        );
        fxController.addClip(clip);

        stateTransitionTime = gNowMs + 2000;
        previousState = currentState;
      } else if (inputState.connected) {
        stateTransitionTime = 0;
        previousState = currentState;
        currentState = StateEnum.connected;
      } else if (gNowMs >= stateTransitionTime) {
        // continue trying to connect? or do we eventually reset
        console.log("still connecting...");
        stateTransitionTime = gNowMs + 2000;
      }
      break;
    case StateEnum.off_transition :
      if (previousState !== currentState) {
        // state entry
        stateTransitionTime = gNowMs + 2000;

        let params = new Fx_AnimationParams();
        let clip = new Fx_Controller_Clip(
          Fx_Animations.fadeToBlack, // animation
          gNowMs,                    // startTime
          2000,                      // duration
          0,                         // repeat
          params,
        );
        fxController.addClip(clip);
      } else if (gNowMs >= stateTransitionTime) {
        previousState = currentState;
        currentState = StateEnum.off_state;
      }
      break;
    case StateEnum.off_state :
      fxController.reset();
      // inputController.reset();
      break;
    case StateEnum.connected :
      // kind of an "idle" or "getting input" state
      if (previousState !== currentState) {
        // state entry, queue up an animation
        fxController.reset();
        let params = new Fx_AnimationParams();
        let clip = new Fx_Controller_Clip(
          Fx_Animations.swipe,       // animation
          gNowMs,                    // startTime
          2000,                      // duration
          Infinity,                  // repeat
          params,
        );
        fxController.addClip(clip);
        previousState = currentState;
      }
      if (!inputState.connected) {
        previousState = currentState;
        currentState = StateEnum.connecting;
        return;
      }
      break;
  }
}

function display() {
  for(let i=0; i<NUM_PIXELS; i++) {
    let r = clamp(
      fxController.backgroundPixels[i].r + fxController.foregroundPixels[i].r,
      0, 255
    );
    let g = clamp(
      fxController.backgroundPixels[i].g + fxController.foregroundPixels[i].g,
      0, 255
    );
    let b = clamp(
      fxController.backgroundPixels[i].b + fxController.foregroundPixels[i].b,
      0, 255
    );
    setPixelColor(i, r, g, b);
  }
}

function main() {
  currentState = StateEnum.start_state;
  console.log("preparing strip");
  prepareStrip();
  console.log("calling setup");
  setup();
  loop();
  console.log("/main");
}

function prepareStrip() {
  let container = document.querySelector("#strip");
  let scale = 500;
  for(let i=0; i<NUM_PIXELS; i++) {
    let child = document.createElement("div");
    child.classList.add("led");
    child.id = "led_" + (NUM_PIXELS -1 - i);
    var x = scale * Math.cos(Math.PI * i / NUM_PIXELS);
    var y = scale * Math.sin(-1 * Math.PI * (i + 0.5) / NUM_PIXELS);
    child.style.left = `${x}px`;
    child.style.top = `${y}px`;
    container.appendChild(child);
  }
}

function setPixelColor(i, r, g, b) {
  let led = document.getElementById("led_" + i);
  led.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
}

document.addEventListener("DOMContentLoaded", main);

</script>
<script type="text/javascript" src="./Fx_Controller.js"></script>
<script type="text/javascript" src="./Input_Controller.js"></script>
<script type="text/javascript" src="./Fx_Animations.js"></script>
</body>
</html>
